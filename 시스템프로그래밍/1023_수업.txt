리 다이렉션 기능

iotest.c

abc 파일

abcde
ttttt
aaaaa
bbbbb

./iotest < ./abc 
표준입력 말고 ./abc에서 입력을 받아라, 
실행 시 abc 파일 내용이 나옴

./iotest< ./abc > message
입력을 ./abc에서 받고, 출력은 message에서 출력을 해 준다.
실행 시 message란 파일이 만들어지고 거기에 abc파일 내용이 써짐 화면엔 출력 x
< : 입력
> : 출력

io <./abc | wc

| : 파이프, 앞 프로그램의 표준 출력을 뒤 프로그램의 표준 입력으로 쓰겠다.

./abc 파일을 입력으로 받고, wc로 출력을 해줌
wc는 워드카운트, 글자의 숫자를 출력

>> 를 하면 업핸드임, >는 새로만들지만 >>는 기존에 있던 파일에 추가

파일의 소유자가 루트인 경우 루트에게 권한을 요청해야함

많은 사용자들이 비밀번호를 바꾸려고 요청하면 루트에게 너무 과한 부담이 치중되므로
ruid와 euid를 나눔. real id는 ㅇㅇㅇ지만, 실행 순간에는 effective user id로 바꾸어 
실행되어야 함

euid : 실제 실행 시에 어떤 접근 권한을 갖는가.
ruid : 유저의 패스워드

ruid와 euid는 다를 수 있음

멀티 유저 환경이기때문에 이러한 권한 설정이 필요함

set user id : s real id와 effective id 가 다를 때 effective 유저의 권한으로 실행

mast&umask

filedes = open("newfile", O_WRONLY | O_CREAT, 0666 );
ls -l newfile시 -rw-rw-rw-로 나와야 하지만 
실제로는 -rw-r--r-- 이렇게 나온다. 

이때 umask 값을 확인 해 보면 022임
umask 값은 거꾸로 되어있음, 0은 모든 권한, 2는 w권한은 빼라
따라서 유저는 rw모든값이 들어가고, 그룹과 오너 권한은 w권한은 빼고 들어가있음

mask & umask 시스템 콜

#include <sys/types.h>
#include <sys/stat.h>

mode_t umask(mode_t newmask);

새로운 값을 주면 , 리턴값은 올드임 특정 기법임, 기억 해 둘 것

int argc char* argv[])


unlink의 실제 역할 (시스템 콜)
링크 카운트를 하나씩 줄여주는 것